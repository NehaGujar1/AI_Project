# -*- coding: utf-8 -*-
"""Tornado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b8xHZ9xk-kMr6g8BHpP9BdzNRXJxa_Ax
"""

import pandas as pd
# dataset = pd.read_csv('kerala.csv')
# dataset = dataset.replace({'FLOODS': {'YES': 1, 'NO': 0}})

# x = dataset.drop(columns=["FLOODS","SUBDIVISION"]) #input

# y = dataset["FLOODS"] #output

# import matplotlib.pyplot as plt
# import numpy as np
# x1 = dataset.drop(columns=["SUBDIVISION","FLOODS","YEAR"])
# y1 = dataset["YEAR"]
# plt.plot(y1, x1, '.')
# plt.show()

# from sklearn.model_selection import train_test_split
# x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.2)

# import tensorflow as tf
# model = tf.keras.models.Sequential()

# model.add(tf.keras.layers.Dense(256, input_shape=x_train.shape[1:], activation='sigmoid'))
# model.add(tf.keras.layers.Dense(256, activation='sigmoid'))
# model.add(tf.keras.layers.Dense(1, activation='sigmoid'))

# model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# model.fit(x_train, y_train, epochs=1000)

# model.evaluate(x_test, y_test)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
# %matplotlib inline
data1 = pd.read_csv('us_tornado_dataset_1950_2021.csv')
data1 = data1.drop(columns=["yr","mo","dy","date"])
x3 = data1.drop(columns=["st"])
y3 = data1["st"]
data1.head()
#linear regression

sns.heatmap(data1.corr())

# plt.scatter(x3,y3,color='blue',marker='*')
from sklearn import linear_model
data1le = data1
data1le.st = le.fit_transform(data1le.st)
X = data1le[["wid","len","elon","elat","slon","slat","fat","inj","mag"]]
Y = data1le["st"]
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,Y,test_size=0.2)
reg = linear_model.LinearRegression()
reg.fit(x_train,y_train)
reg.coef_
reg.intercept_
# reg.predict([[42,43,10]])
reg.score(x_test,y_test)

import pickle
with open('model_pickle','wb') as f:
  pickle.dump(data1,f)

with open('model_pickle','rb') as f:
  mp=pickle.load(f)

from sklearn import externals
import joblib

joblib.dump(data1,'model_joblib')
mj = joblib.load('model_joblib')
# mj.predict([[42,43,10]])

from sklearn.linear_model import LogisticRegression
md = LogisticRegression()
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x3,y3,test_size=0.2)
md.fit(x_train, y_train)
# md.predict([[42,43,10]])
md.score(x_test,y_test)
# md.predict_proba(x_test)

y_predicted = md.predict(x_test)
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_predicted)
sns.heatmap(cm,annot=True)
plt.xlabel('Predicted')
plt.ylabel('Truth')

# mp.predict([[42,43,10]])

from sklearn import tree
md = tree.DecisionTreeClassifier()
md.fit(x_train,y_train)
md.score(x_test,y_test)

import joblib
joblib.dump(md,'Model3')
print("Training and testing complete" )
