# -*- coding: utf-8 -*-
"""Tornado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b8xHZ9xk-kMr6g8BHpP9BdzNRXJxa_Ax
"""

import pandas as pd
# dataset = pd.read_csv('kerala.csv')
# dataset = dataset.replace({'FLOODS': {'YES': 1, 'NO': 0}})

# x = dataset.drop(columns=["FLOODS","SUBDIVISION"]) #input

# y = dataset["FLOODS"] #output

# import matplotlib.pyplot as plt
# import numpy as np
# x1 = dataset.drop(columns=["SUBDIVISION","FLOODS","YEAR"])
# y1 = dataset["YEAR"]
# plt.plot(y1, x1, '.')
# plt.show()

# from sklearn.model_selection import train_test_split
# x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.2)

# import tensorflow as tf
# model = tf.keras.models.Sequential()

# model.add(tf.keras.layers.Dense(256, input_shape=x_train.shape[1:], activation='sigmoid'))
# model.add(tf.keras.layers.Dense(256, activation='sigmoid'))
# model.add(tf.keras.layers.Dense(1, activation='sigmoid'))

# model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# model.fit(x_train, y_train, epochs=1000)

# model.evaluate(x_test, y_test)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
# %matplotlib inline
data1 = pd.read_csv('us_tornado_dataset_1950_2021.csv')
data1 = data1.drop(columns=["yr","mo","dy","date"])
x3 = data1.drop(columns=["st"])
y3 = data1["st"]
data1.head()
#linear regression

sns.heatmap(data1.corr())

# plt.scatter(x3,y3,color='blue',marker='*')
from sklearn import linear_model
data1le = data1
data1le.st = le.fit_transform(data1le.st)
X = data1le[["wid","len","elon","elat","slon","slat","fat","inj","mag"]]
Y = data1le["st"]
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,Y,test_size=0.2)
reg = linear_model.LinearRegression()
reg.fit(x_train,y_train)
reg.coef_
reg.intercept_
# reg.predict([[42,43,10]])
reg.score(x_test,y_test)

import pickle
with open('model_pickle','wb') as f:
  pickle.dump(data1,f)

with open('model_pickle','rb') as f:
  mp=pickle.load(f)

from sklearn import externals
import joblib

joblib.dump(data1,'model_joblib')
mj = joblib.load('model_joblib')
# mj.predict([[42,43,10]])

from sklearn.linear_model import LogisticRegression
md = LogisticRegression()
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x3,y3,test_size=0.2)
md.fit(x_train, y_train)
# md.predict([[42,43,10]])
md.score(x_test,y_test)
# md.predict_proba(x_test)

y_predicted = md.predict(x_test)
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_predicted)
sns.heatmap(cm,annot=True)
plt.xlabel('Predicted')
plt.ylabel('Truth')

# mp.predict([[42,43,10]])

from sklearn import tree
md = tree.DecisionTreeClassifier()
md.fit(x_train,y_train)
md.score(x_test,y_test)
# md.predict([[42,43,10]])

# from sklearn.svm import SVC
# sv = SVC(C=10, kernel='linear') #C=> regularization = distance
# sv.fit(x_train,y_train)
# sv.score(x_test,y_test)

from sklearn.ensemble import RandomForestClassifier
rfc = RandomForestClassifier(n_estimators=60)
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x3,y3,test_size=0.2)
rfc.fit(x_train,y_train)
rfc.score(x_test,y_test)
y_predicted2 = rfc.predict(x_test)
cm2 = confusion_matrix(y_test, y_predicted2)
cm2
sns.heatmap(cm2,annot=True)
plt.xlabel('Predicted')
plt.ylabel('Truth')

from sklearn.model_selection import KFold
kf = KFold(n_splits=3)
kf

for train_index, test_index in kf.split([1,2,3,4,5,6,7,8,9]):
  print(train_index, test_index )

def get_score(model,x_train,x_test,y_train,y_test):
  model.fit(x_train,y_train)
  return model.score(x_test,y_test)

from sklearn.model_selection import StratifiedKFold
folds = StratifiedKFold(n_splits=3)
score_l = []
score_sv = []
score_rf = []
from sklearn.svm import SVC
for train_index, test_index in kf.split(x3):
  x1_train,x1_test,y1_train,y1_test = x3.values[train_index], x3.values[test_index], y3.values[train_index], y3.values[test_index]
  score_sv.append(get_score(SVC(),x1_train,x1_test,y1_train,y1_test ))
  score_l.append(get_score(LogisticRegression(),x1_train,x1_test,y1_train,y1_test ))
  score_rf.append(get_score(RandomForestClassifier(n_estimators=40),x1_train,x1_test,y1_train,y1_test ))

from sklearn.model_selection import cross_val_score
cross_val_score(LogisticRegression(),x3,y3)

cross_val_score(SVC(),x3,y3)

cross_val_score(RandomForestClassifier(),x3,y3)

# plt.scatter(x3,y3)
from sklearn.cluster import KMeans
km = KMeans(n_clusters=4)
km

# y_predict = km.fit_predict([x3,y3])
from sklearn.model_selection import GridSearchCV
clf = GridSearchCV(SVC(gamma='auto'),
                   {
                      'C':[10,20,1],
                      'kernel':['rbf','linear']
                   }, cv=5, return_train_score=False)
clf.fit(x3,y3)
clf.cv_results_

df = pd.DataFrame(clf.cv_results_)
df

clf.best_score_

clf.best_params_

from sklearn.model_selection import RandomizedSearchCV
rlf = RandomizedSearchCV(SVC(gamma='auto'),
                   {
                      'C':[10,20,1],
                      'kernel':['rbf','linear']
                   }, cv=5, return_train_score=False, n_iter=3)
rlf.fit(x3,y3)
rlf.cv_results_
rlf.best_score_

model_params = {
    'svm': {
        'model': SVC(gamma='auto'),
        'params' : {
            'C': [1,10,20],
            'kernel': ['rbf','linear']
        }
    },
    'random_forest': {
        'model': RandomForestClassifier(),
        'params' : {
            'n_estimators': [1,5,10]
        }
    },
    'logistic_regression' : {
        'model': LogisticRegression(solver='liblinear',multi_class='auto'),
        'params': {
            'C': [1,5,10]
        }
    }
}
scores = []

for model_name, mp in model_params.items():
    clf =  GridSearchCV(mp['model'], mp['params'], cv=5, return_train_score=False)
    clf.fit(x3, y3)
    scores.append({
        'model': model_name,
        'best_score': clf.best_score_,
        'best_params': clf.best_params_
    })

df = pd.DataFrame(scores,columns=['model','best_score','best_params'])
df