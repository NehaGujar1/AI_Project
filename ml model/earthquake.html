<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="earthquake.css">
</head>
<body id="bg" style="font-family: 'Comic Sans MS';">
    <div class="add_space"></div>
    <div id="divi"><h1><p id="main_text">Enter rainfall in ml</p></h1></div>
    <input style="justify-self: center;margin: auto; display: block; height: 4vh; width: 10vw; background-color: #ffffffaf; font-size: 2vh; text-align: center;" type="number" id="rain_val" />
    <div class="add_space2"></div>
    <button style="justify-self: center;margin: auto; display: block; height: 4vh; width: 10vw; background-color: #ffffffaf; font-weight: bolder; font-size: 2vh;" type="button" onclick="takeInput()">PREDICT</button>

    <!-- <script>
    function takeInput() {
        let x = document.getElementById("rain_val").value;
        console.log(x)
    }
    </script> -->
    <py-env>
        - numpy
        - pandas
        - sklearn
        - seaborn
        - matplotlib.pyplot
    </py-env>
    <py-script>
        # -*- coding: utf-8 -*-
"""Earthquake.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vsVlH4YaePSTa6pWOyzwN_5NdwMsQWHm
"""

# Commented out IPython magic to ensure Python compatibility.
from js import (
            document,
            Blob,
            URL
        )
from pyodide import create_proxy
def inputval():
    Time	Place	Latitude	Longitude	Depth	Mag	MagType	nst	gap	dmin	rms	net	ID	Updated		Type	horizontalError	depthError	magError	magNst	status	locationSource	magSource
    Temperature = document.getElementById("Temperature")
    RH = document.getElementById("RH")
    Ws = document.getElementById("Ws")
    Rain = document.getElementById("Rain")
    FFMC = document.getElementById("FFMC")
    DMC = document.getElementById("DMC")
    DC = document.getElementById("DC")
    ISI = document.getElementById("ISI")
    BUI = document.getElementById("BUI")
    FWI = document.getElementById("FWI")
    inputvals = [Temperature,  RH, Ws, Rain , FFMC, DMC, DC, ISI, BUI, FWI]
    earthqpred(inputvals)
e = document.getElementById("makeprediction")
e.addEventListener("click",create_proxy(inputval))

import pandas as pd
# import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
# %matplotlib inline
def earthqpred(inputvals) :
    data1 = pd.read_csv('Significant Earthquake Dataset 1900-2023.csv')
    data1 = data1.fillna(0)
    # data1["Type"]
    # # filter = (data1["Type"] == 'earthquake').any()
    data1 = data1[data1["Type"] == 'earthquake']
    data1.magSource = le.fit_transform(data1.magSource)
    data1.MagType = le.fit_transform(data1.MagType)
    data1.net = le.fit_transform(data1.net)
    data1.locationSource = le.fit_transform(data1.locationSource)
    data1.Type = le.fit_transform(data1.Type)
    data1 = data1.drop(columns=["Time","Place","ID","Updated","Unnamed: 14","magError","status","Type","locationSource","magSource","net"])
    x3 = data1.drop(columns=["Mag"])
    y3 = data1["Mag"]
    data1.head()
    # data1["Type"]
    # data1["magSource"]

    # sns.heatmap(data1.corr())

    from sklearn.model_selection import train_test_split
    x_train, x_test, y_train, y_test = train_test_split(x3,y3,test_size=0.2)
    from sklearn import tree
    md = tree.DecisionTreeRegressor(random_state=42)
    # from sklearn.metrics import r2_score
    # md = r2_score()
    md.fit(x_train,y_train)
    md.score(x_test,y_test)
    # y_predicted = md.predict(x_test)
    # from sklearn.metrics import confusion_matrix
    # cm = confusion_matrix(y_test, y_predicted)
    # sns.heatmap(cm,annot=True)
    # plt.xlabel('Predicted')
    # plt.ylabel('Truth')

    from xgboost import XGBRegressor
    md = XGBRegressor()
    md.fit(x_train,y_train)
    md.score(x_test,y_test)
    
    pyscript.write('tsunami',md.predict(inputvals))
    from sklearn.ensemble import RandomForestRegressor
    md = RandomForestRegressor()
    md.fit(x_train,y_train)
    md.score(x_test,y_test)

    </py-script>
</body>
</html>